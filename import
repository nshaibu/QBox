#!/bin/bash

#===========================================================================================
# Copyright (C) 2017 Nafiu Shaibu.
# Purpose: General library including system
#-------------------------------------------------------------------------------------------
# This is is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option) 
# any later version.

# This is distributed in the hopes that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#===========================================================================================

: ${LIB_DIR:=$HOME/my_script/QB}

. ${LIB_DIR}/include


if [[ $1 = "<init.h>" ]]; then
	
	if NOT_DEFINE ${INIT_H}; then
		DEFINE INIT_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		##global variables
		: ${HD_IMG_DIR:="$HOME/.img_qemubox"}
		: ${TEMP_FOLDER:="${HD_IMG_DIR}/.tmp_qbox"}
		: ${QDB_FOLDER=:"${HD_IMG_DIR}/.qdb"} ##qbox database files location
		: ${LOG_DIR:="${HD_IMG_DIR}/logs_dir"}
		: ${BOOT_DIR:="${HD_IMG_DIR}/.qemuboot"} ## contain boot files
		
		
		#librarry dir 
		: ${LIB_DIR:=$HOME/my_script/QB}
		
		#python directory
		: ${PYTHON_LOC:=${QBOX_DIR}/python3}
				
		#Installation Directory 
		: ${QBOX_DIR:="/usr/local/bin/QBox"}
		
		export SDL_VIDEO_X11_DGAMOUSE=0 ##to prevent qemu cursor from been difficult to control
		
		[ ! -d ${HD_IMG_DIR} ] && mkdir ${HD_IMG_DIR} ##Check and creates Harddisk image folder
		[ ! -d ${BOOT_DIR} ] && mkdir ${BOOT_DIR} ##check and create boot folder
		[ ! -d ${QDB_FOLDER} ] && mkdir ${QDB_FOLDER} ##check for qbox database folder
		[ ! -d ${TEMP_FOLDER} ] && mkdir ${TEMP_FOLDER} ##check and creates tmp folder
		[ ! -d ${LOG_DIR} ] && mkdir ${LOG_DIR} && touch ${LOG_DIR}/qboxlog ##check and create log directory
		[ ! -f ${QDB_FOLDER}/pid.qdb ] && touch ${QDB_FOLDER}/pid.qdb ##check pid database vm_name|pid
		[ ! -f ${QDB_FOLDER}/vms.qdb ] && touch ${QDB_FOLDER}/vms.qdb
		
		echo -ne "\033]0;QBox Easy VM Manager \007"
		
		function _clear_pid_qdb_event() {
			if [ "<${PID_DB}" != "" ]; then
				for i in `cut -d "|" -f2 ${PID_DB}`;do 
					
					if [ ! -d /proc/$i ]; then
						name="^$i\$"
						echo $(gawk -F "|" -v var=$name '$2 !~ var {print $0}' ${PID_DB}) > ${TEMP_FOLDER}/vms.tt
						##replace black or space character with newline character
						sed -e 's/[[:blank:]]\+/\n/g' ${TEMP_FOLDER}/vms.tt 2>/dev/null 1> ${QDB_FOLDER}/pid.qdb
						rm -f ${TEMP_FOLDER}/vms.tt 2>/dev/null
					fi 
				done 
			fi 
		}	
		
#		function _clear_pid_qdb() {
#			local pid_t=""
#			local TMPFILE=$(mktemp -uq qbox.XXXXXXXXXXXX || echo "qbox.$$")
#			
#			[ "`cat <${PID_DB}`" != "" ] && {
#				for i in $(cut -d "|" -f2 ${PID_DB}); do 
#					pid_t=$(ps ax | awk '{print $1}' | grep $i) 
#				done
#				
#				if [[ -z ${pid_t} ]]; then
#					complement_of ${pid_t} ${PID_DB} "${TEMP_FOLDER}/${TMPFILE}"
#					#echo $(gawk -F "|" -v var=$name '$2 !~ var {print $0}' ${PID_DB}) > ${TEMP_FOLDER}/vms.tt
#					##replace black or space character with newline character
#					sed -e 's/[[:blank:]]\+/\n/g' "${TEMP_FOLDER}/${TMPFILE}" 2>/dev/null 1> ${PID_DB}
#					rm -f "${TEMP_FOLDER}/${TMPFILE}" 2>/dev/null					
#				fi 
#			}
#		}
		
	fi ## INIT_H
	
elif [[ $1 = "<notify.h>" ]]; then
	
	NOT_DEFINE ${NOTIFY_H} && {
		DEFINE NOTIFY_H
		
		: ${NOTICE:=`${QBOX_DIR}/bash_s/check_pkg_install.sh %CHECK_RUN% notify-send`}
	} # NOTIFY_H
	
elif [[ $1 = "<qdb_database.h>" ]]; then
	
	NOT_DEFINE ${QDB_DATABASE_H} && {
		DEFINE QDB_DATABASE_H
		
		. ${LIB_DIR}/import '<init.h>'
		
		DEFINE ARR_IS_EMPTY -1
		DEFINE SRCH_VAL_NOT_IN_ARR -2
		
		if NOT_DEFINE ${ERROR_H} || NOT_DEFINE ${BASIC_UTILS_H}; then
			. ${LIB_DIR}/include '<error.h>'
			. ${LIB_DIR}/include '<basic_utils.h>'
		fi 
		
		: ${VMS_DB:="${QDB_FOLDER}/vms.qdb"}
		: ${PID_DB:="${QDB_FOLDER}/pid.qdb"}
		
		function return_first_field() {
			if check_is_file $1 ; then
				echo -n "$(cut -d"|" -f1 $1)"
			else 
				echo -n "$(echo $1 | cut -d"|" -f1)"
			fi 
		}
		
		function return_second_field() {
			if check_is_file $1; then
				echo -n "$(cut -d"|" -f2 $1)"
			else 
				echo -n "$(echo $1 | cut -d"|" -f2)"
			fi 
		}
		
		function return_n_field() {
			local field=$2
			local delimiter="$3"
			
			if check_is_file $1; then
				echo -n "$(cut -d"${delimiter}" -f ${field} $1)"
			else 
				echo -n "$(echo $1 | cut -d"${delimiter}" -f ${field})"
			fi 		
		}
		
		# value, input file, output file
		function complement_of() {
			local search="^$1\$"
			gawk -F "|" -v var=$search '$1 !~ var {print $0}' $2 1>$3
			
		}
		
		#it returns the name of all vms by assigned it to an array and return SUCCESS if successful
		#ARGU: DB_NAME
		#RET: ARR_
		function init_database_qdb() {
			local i=0
			local -a qdb_name
			
			check_is_file $1 && {
				if [[ "<$1" != "" ]]; then
					for j in $(cat $1); do 
						qdb_name[$i]="\"$j\""
						(( i++ ))
					done 
					echo "${qdb_name[@]}"
				fi 
			} || { err_code=${QDB_NOT_EXIT}; }
			
		}
		
		#ARGU:	array of values contain the search value at the end of the array
		#RET:	ARR_INDEX
		function search_val_qdb() {
			local -a qdb_vm_info=( $@ )
			local sizeof_arr=${#qdb_vm_info[@]}
			local search_val=${qdb_vm_info[$(( --sizeof_arr ))]} && unset 'qdb_vm_info[$sizeof_arr]' 
			
			[ ${sizeof_arr} -eq 1 ]  && echo ${qdb_vm_info[@]} && return ${ARR_IS_EMPTY}
			
			if [[ ${sizeof_arr} -gt 1 ]]; then
				for (( index=0; index<${#qdb_vm_info[@]}; index++ )); do 
					[ "${qdb_vm_info[$index]%%:*}" = "$(String_to_Upper ${search_val})" ] && echo ${qdb_vm_info[@]} && return ${index} 
				done 
			fi
			
			echo ${qdb_vm_info[@]}
			return ${SRCH_VAL_NOT_IN_ARR}
		}
		
		###generate string from arr of vms sizeof_arr, set_str
		function names_str_qdb() {
			local -a qdb_name=( $@ )
			local gen_str=""
			local str_tmp=""
			
			for (( index=0; index<${#qdb_name[@]}; index++ )); do 
					str_tmp="${qdb_name[$index]//\"/}"
					str_tmp="${str_tmp// /_}"
					gen_str+="%$(( index+1 ))%${str_tmp%%|*}"
			done
			
			echo -n ${gen_str//%/ }
		}
		
		#argu: db_name, var_to_insert
		function insert_into_qdb() {
			echo $2>>$1
		}
		
		function delete_msg_qdb() {
			${DIALOG} \
				--keep-window --colors --title "\Zb\Z1INFO\Zn\ZB" --yesno "\n\nDo you really want to \Zb\Z1delete $1\Zn\ZB" $((HEIGHT-7)) $((WIDTH-20))	
			
			case $? in 
				${DIALOG_OK}) return ${SUCCESS} ;;
				${DIALOG_CANCEL}) return ${FAILURE} ;;
			esac
		}
		
		#argu:	are all assigned to an array "search_index|name_of_vm_to_del|db_type" and the array is passed to the function
		function delete_val_qdb() {
			local -a qdb_name=( $@ ) ##get all db values
			declare -i sizeof_arr=${#qdb_name[@]}
				
			local qdb_type=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
			local info_vm_to_del=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
			local key=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
				
			[ $key -eq ${ARR_IS_EMPTY} ] && return ${ARR_IS_EMPTY}
			[ $key -eq ${SRCH_VAL_NOT_IN_ARR} ] && return ${SRCH_VAL_NOT_IN_ARR}
			
			[ $key -gt 0 ] && {		
				local boot_file_name=$(return_second_field ${info_vm_to_del})
				
				while [[ ${key} -lt ${#qdb_name[@]} ]]; do 
					qdb_name[$key]=${qdb_name[$(( key + 1 ))]}
					(( key++ ))
				done
				
				unset 'qdb_name[$(( --key ))]' ##delete the last slot to reduce the size of arr by 1
				
				##-----commit changes to db files--------------
				local TMPFILE=$(mktemp -uq qbox.XXXXXXXXXXXX || echo "qbox.$$")
				local vm_name=$(return_first_field ${info_vm_to_del})
				local vm_name=${vm_name//\"/}
				
				complement_of ${vm_name} "${qdb_type}" "${QDB_FOLDER}/${TMPFILE}"
				local hd_img=${boot_file_name/.qvm/.img}
				
				mv "${QDB_FOLDER}/${TMPFILE}" ${qdb_type} 
				rm -f "${BOOT_DIR}/${boot_file_name}" 2>/dev/null
				rm -f "${HD_IMG_DIR}/${hd_img}" 2>/dev/null
				
				echo -n "${qdb_name[@]}"
				return 0
			}
		}
		
	}
	
elif [[ $1 = "<boot_vm.h>" ]]; then
	
	NOT_DEFINE ${BOOT_VM_H} && {
		DEFINE BOOT_VM_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		if NOT_DEFINE ${TRUE_TEST_H}; then
			. ${LIB_DIR}/include '<true_test.h>'
		fi 
		
		##arrgu: bootfile, name of vm
		function boot_vm() {
			local boot_config=""
			local boot_file_loc="${BOOT_DIR}/$1"
			
			if check_is_file ${boot_file_loc}; then
				boot_config=$(cat ${boot_file_loc} | cut -d"|" -f2 | sed ':a;N;$!ba;s/\n/ /g')
				
				boot_config=`echo ${boot_config} | tr -s " "` ##Replace multiple space char with a space char
				
				boot_config=${boot_config// ,/,} ##Replace " ," with ","
				
				${boot_config} 2>/dev/null &
				local pid_vm=$!
				
				insert_into_qdb ${PID_DB} "$2|${pid_vm}"
				return ${SUCCESS}
			else 
				return ${FAILURE}
			fi 
		}
		
		#argu: name_of_vm_to_boot
		function startvm() {
			local -a QDB_ARR=( $(init_database_qdb ${VMS_DB}) ) ##initialize qdb
			local sizeof_arr=${#QDB_ARR[@]}
			
			if [[ ${sizeof_arr} -gt 0 ]]; then
				QDB_ARR[$(( sizeof_arr ))]=$1
				QDB_ARR=( $(search_val_qdb ${QDB_ARR[@]}) )
				let vm_info_index=$?
				
				[ "${vm_info_index}" != "${ARR_IS_EMPTY}" ] && [ "${vm_info_index}" != "${SRCH_VAL_NOT_IN_ARR}" ] && {
					vm_info=QDB_ARR[${vm_info_index}]
					vm_info=$(return_second_field ${vm_info})
					boot_vm ${vm_info} 
				}
			fi 
		}
	} ## BOOT_VM_H
	
elif [[ $1 = "<http_server.h>" ]]; then
	
	NOT_DEFINE ${HTTP_SERVER_H} && {
		DEFINE HTTP_SERVER_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		: ${PHP_PARSER:=`$QBOX_DIR/bash_s/check_pkg_install.sh %CHECK_RUN% php`}
		: ${TCP_SERVER:=$($QBOX_DIR/bash_s/check_pkg_install.sh %CHECK_RUN% ncat)}
		
		: ${DOC_ROOT:="${QBOX_DIR}/www"}
		: ${test_serv_running:="${TEMP_FOLDER}/.svrpid"}
		
		#request to tcp server
		DEFINE BOOT_REQUEST 521
		DEFINE STOP_VM_REQUEST 522
		DEFINE LIST_VM_REQUET 523
		
		if NOT_DEFINE ${HOST_IP_H} || NOT_DEFINE ${BASIC_UTILS_H} || NOT_DEFINE ${LOGGS_H} || NOT_DEFINE ${TRUE_TEST_H} ; then
			. ${LIB_DIR}/include '<host_ip.h>'
			. ${LIB_DIR}/include '<basic_utils.h>'
			. ${LIB_DIR}/include '<loggs.h>'
			. ${LIB_DIR}/include '<true_test.h>'
		fi 
		
		: ${PID_MAX:=$(cat /proc/sys/kernel/pid_max 2>/dev/null || echo -n 32768)}
		
		function httpd_start() {
			${PHP_PARSER} -S ${HOST_IP}:4020 -t ${DOC_ROOT} 1>${LOGS_FILE} 2>&1 &
			local pid_s=$!
			
			logger_logging ${LOGS_FILE}
			[ ${pid_s} -gt 1 ] && [ ${pid_s} -le ${PID_MAX} ] && { echo -n "${pid_s}|${HOST_IP}"; } || { echo -n "-1"; }
		}
		
		function list_created_vms() {
			local -a QDB_ARR=( $(init_database_qdb ${VMS_DB}) ) ##initialize qdb
			
			if [[ ${#QDB_ARR[*]} -ne 0 ]]; then
				local gen_str_=$(names_str_qdb ${QDB_ARR[@]})
			else
				local gen_str_="No_Virtual_Machine_created_yet..."
			fi
			
			gen_str_=${gen_str_//\"/}
			gen_str_=${gen_str_//[[:digit:]]/}
			gen_str_=${gen_str_//[[:space:]]/:}
			
			echo -n ${gen_str_}
		}
		
				#HD_IMG_DIR="$HOME/.img_qemubox"
				#QDB_FOLDER="${HD_IMG_DIR}/.qdb"
				#VMS_DB="${QDB_FOLDER}/vms.qdb"		
		
		function qbox_server_start() {
			${TCP_SERVER} -l -p 4040 -c '
				: ${LIB_DIR:=$HOME/my_script/QB}
				
				#. ${LIB_DIR}/import "<http_server.h>"
				
				while true ; do 
					read request
					
					case ${request} in 
						${LIST_VM_REQUET}) echo 1 ;; #list_created_vms ;;
						${BOOT_REQUEST}) ;;
						${STOP_VM_REQUEST}) ;;
					esac
				done 
			'
		}
		
		#stop service
		function server_stop() {
			kill -9 $@ 2>/dev/null
			
			[ $? -eq ${SUCCESS} ] && return ${SUCCESS} || return ${FAILURE}
		}
		
		#test server is runing
		function server_is_not_running() {
			if check_is_file ${test_serv_running}; then
				return ${FAILURE} 
			else 
				return ${SUCCESS}
			fi 
		}
		
	} ## HTTP_SERVER_H
fi
