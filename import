#!/bin/bash

#===========================================================================================
# Copyright (C) 2017 Nafiu Shaibu.
# Purpose: General library including system
#-------------------------------------------------------------------------------------------
# This is is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option) 
# any later version.

# This is distributed in the hopes that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#===========================================================================================

: ${LIB_DIR:=$HOME/my_script/QB}

. ${LIB_DIR}/include


if [[ $1 = "<init.h>" ]]; then
	
	if NOT_DEFINE ${INIT_H}; then
		DEFINE INIT_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		##global variables
		: ${HD_IMG_DIR:="$HOME/.img_qemubox"}
		: ${TEMP_FOLDER:="${HD_IMG_DIR}/.tmp_qbox"}
		: ${QDB_FOLDER=:"${HD_IMG_DIR}/.qdb"} ##qbox database files location
		: ${LOG_DIR:="${HD_IMG_DIR}/logs_dir"}
		: ${BOOT_DIR:="${HD_IMG_DIR}/.qemuboot"} ## contain boot files
		
		
		#librarry dir 
		: ${LIB_DIR:=$HOME/my_script/QB}
		
		#python directory
		: ${PYTHON_LOC:=${QBOX_DIR}/python3}
				
		#Installation Directory 
		: ${QBOX_DIR:="/usr/local/bin/QBox"}
		
		export SDL_VIDEO_X11_DGAMOUSE=0 ##to prevent qemu cursor from been difficult to control
		
		[ ! -d ${HD_IMG_DIR} ] && mkdir ${HD_IMG_DIR} ##Check and creates Harddisk image folder
		[ ! -d ${BOOT_DIR} ] && mkdir ${BOOT_DIR} ##check and create boot folder
		[ ! -d ${QDB_FOLDER} ] && mkdir ${QDB_FOLDER} ##check for qbox database folder
		[ ! -d ${TEMP_FOLDER} ] && mkdir ${TEMP_FOLDER} ##check and creates tmp folder
		[ ! -d ${LOG_DIR} ] && mkdir ${LOG_DIR} && touch ${LOG_DIR}/qboxlog ##check and create log directory
		[ ! -f ${QDB_FOLDER}/pid.qdb ] && touch ${QDB_FOLDER}/pid.qdb ##check pid database vm_name|pid
		[ ! -f ${QDB_FOLDER}/vms.qdb ] && touch ${QDB_FOLDER}/vms.qdb
		
		echo -ne "\033]0;QBox Easy VM Manager \007"
		
		function VM_clear_pid_qdb_eventhandler() {
			if [ "<${PID_DB}" != "" ]; then
				for i in `cut -d "|" -f2 ${PID_DB}`;do 
					
					if [ ! -d /proc/$i ]; then
						name="^$i\$"
						echo $(gawk -F "|" -v var=$name '$2 !~ var {print $0}' ${QDB_FOLDER}/pid.qdb) > ${TEMP_FOLDER}/vms.tt
						##replace black or space character with newline character
						sed -e 's/[[:blank:]]\+/\n/g' ${TEMP_FOLDER}/vms.tt 2>/dev/null 1> ${QDB_FOLDER}/pid.qdb
						rm -f ${TEMP_FOLDER}/vms.tt 2>/dev/null
					fi 
				done 
			fi 
		}	
		
	fi 
	
elif [[ $1 = "<notify.h>" ]]; then
	
	NOT_DEFINE ${NOTIFY_H} && {
		DEFINE NOTIFY_H
		
		: ${NOTICE:=`${QBOX_DIR}/bash_s/check_pkg_install.sh %CHECK_RUN% notify-send`}
	}
	
elif [[ $1 = "<qdb_database.h>" ]]; then
	
	NOT_DEFINE ${QDB_DATABASE_H} && {
		DEFINE QDB_DATABASE_H
		
		. ${LIB_DIR}/import '<init.h>'
		
		DEFINE ARR_IS_EMPTY -1
		DEFINE SRCH_VAL_NOT_IN_ARR -2
		
		if NOT_DEFINE ${ERROR_H} || NOT_DEFINE ${BASIC_UTILS_H}; then
			. ${LIB_DIR}/include '<error.h>'
			. ${LIB_DIR}/include '<basic_utils.h>'
		fi 
		
		: ${VMS_DB:="${QDB_FOLDER}/vms.qdb"}
		: ${PID_DB:="${QDB_FOLDER}/pid.qdb"}
		
		function return_first_field() {
			if check_is_file $1 ; then
				echo -n "$(cut -d"|" -f1 $1)"
			else 
				echo -n "$(echo $1 | cut -d"|" -f1)"
			fi 
		}
		
		function return_second_field() {
			if check_is_file $1; then
				echo -n "$(cut -d"|" -f2 $1)"
			else 
				echo -n "$(echo $1 | cut -d"|" -f2)"
			fi 
		}
		
		function return_n_field() {
			local field=$2
			local delimiter="$3"
			
			if check_is_file $1; then
				echo -n "$(cut -d"${delimiter}" -f ${field} $1)"
			else 
				echo -n "$(echo $1 | cut -d"${delimiter}" -f ${field})"
			fi 		
		}
		
		# value, input file, output file
		function complement_of() {
			local search="^$1\$"
			echo ${search} >${LIB_DIR}/v.txt
			gawk -F "|" -v var=$search '$1 !~ var {print $0}' $2 1>$3
			
		}
		
		#it returns the name of all vms by assigned it to an array and return SUCCESS if successful
		#ARGU: DB_NAME
		#RET: ARR_
		function init_database_qdb() {
			local i=0
			local -a qdb_name
			
			check_is_file $1 && {
				if [[ "<$1" != "" ]]; then
					for j in $(cat $1); do 
						qdb_name[$i]="\"$j\""
						(( i++ ))
					done 
					echo "${qdb_name[@]}"
				fi 
			} || { err_code=${QDB_NOT_EXIT}; }
			
		}
		
		#ARGU:	VALUE_TO_SEARCH_FOR, SIZE_OF_ARR
		#RET:	ARR_INDEX
		function search_val_qdb() {
			[ $2 -eq 0 ] && return ${ARR_IS_EMPTY}
			
			for (( index=0; index<$2; index++ )); do 
				[ "${QDB_NAME[$index]%%:*}" = "$(String_to_Upper $1)" ] && return ${index} 
			done 
			
			return ${SRCH_VAL_NOT_IN_ARR}
		}
		
		###generate string from arr of vms sizeof_arr, set_str
		function names_str_qdb() {
			local -a qdb_name=( $@ )
			local gen_str=""
			local str_tmp=""
			
			for (( index=0; index<${#qdb_name[@]}; index++ )); do 
					str_tmp="${qdb_name[$index]//\"/}"
					str_tmp="${str_tmp// /_}"
					gen_str+="%$(( index+1 ))%${str_tmp%%|*}"
			done
			
			echo -n ${gen_str//%/ }
		}
		
		#argu: db_name, var_to_insert
		function insert_into_qdb() {
			echo $2>>$1
		}
		
		function delete_msg_qdb() {
			${DIALOG} \
				--keep-window --colors --title "\Zb\Z1INFO\Zn\ZB" --yesno "\n\nDo you really want to \Zb\Z1delete $1\Zn\ZB" $((HEIGHT-7)) $((WIDTH-20))	
			
			case $? in 
				${DIALOG_OK}) return ${SUCCESS} ;;
				${DIALOG_CANCEL}) return ${FAILURE} ;;
			esac
		}
		
		#argu:	are all assigned to an array "search_index|name_of_vm_to_del|db_type" and the array is passed to the function
		function delete_val_qdb() {
			local -a qdb_name=( $@ ) ##get all db values
			declare -i sizeof_arr=${#qdb_name[@]}
				
			local qdb_type=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
			local info_vm_to_del=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
			local key=${qdb_name[$(( --sizeof_arr ))]} && unset 'qdb_name[$sizeof_arr]'
				
			[ $key -eq ${ARR_IS_EMPTY} ] && return ${ARR_IS_EMPTY}
			[ $key -eq ${SRCH_VAL_NOT_IN_ARR} ] && return ${SRCH_VAL_NOT_IN_ARR}
			
			[ $key -gt 0 ] && {		
				local boot_file_name=$(return_second_field ${info_vm_to_del})
				
				while [[ ${key} -lt ${#qdb_name[@]} ]]; do 
					qdb_name[$key]=${qdb_name[$(( key + 1 ))]}
					(( key++ ))
				done
				
				unset 'qdb_name[$(( --key ))]' ##delete the last slot to reduce the size of arr by 1
				
				##-----commit changes to db files--------------
				local TMPFILE=$(mktemp -uq qbox.XXXXXXXXXXXX || echo "qbox.$$")
				local vm_name=$(return_first_field ${info_vm_to_del})
				local vm_name=${vm_name//\"/}
				
				complement_of ${vm_name} "${qdb_type}" "${QDB_FOLDER}/${TMPFILE}"
				local hd_img=${boot_file_name/.qvm/.img}
				
				mv "${QDB_FOLDER}/${TMPFILE}" ${qdb_type} 
				rm -f "${BOOT_DIR}/${boot_file_name}" 2>/dev/null
				rm -f "${HD_IMG_DIR}/${hd_img}" 2>/dev/null
				
				echo -n "${qdb_name[@]}"
				return 0
			}
		}
		
	}
	
elif [[ $1 = "<boot_vm.h>" ]]; then
	
	NOT_DEFINE ${BOOT_VM_H} && {
		DEFINE BOOT_VM_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		if NOT_DEFINE ${TRUE_TEST_H}; then
			. ${LIB_DIR}/include '<true_test.h>'
		fi 
		
		##arrgu: bootfile, name of vm
		function boot_vm() {
			local boot_config=""
			local boot_file_loc="${BOOT_DIR}/$1"
			
			if check_is_file ${boot_file_loc}; then
				boot_config=$(cat ${boot_file_loc} | cut -d"|" -f2 | sed ':a;N;$!ba;s/\n/ /g')
				
				boot_config=`echo ${boot_config} | tr -s " "` ##Replace multiple space char with a space char
				
				boot_config=${boot_config// ,/,} ##Replace " ," with ","
				
				${boot_config} 2>/dev/null &
				local pid_vm=$!
				
				insert_into_qdb ${PID_DB} "$2|${pid_vm}"
				return ${SUCCESS}
			else 
				return ${FAILURE}
			fi 
		}
	}
	
elif [[ $1 = "<http_server.h>" ]]; then
	
	NOT_DEFINE ${HTTP_SERVER_H} && {
		DEFINE HTTP_SERVER_H
		
		: ${PHP_PARSER:=`$QBOX_DIR/bash_s/check_pkg_install.sh %CHECK_RUN% php`}
		: ${DOC_ROOT:="${QBOX_DIR}/www"}
		: ${FILE_TEST_SERV_RUNNING:="${TEMP_FOLDER}/.svrpid"}
		
		if NOT_DEFINE ${HOST_IP_H} || NOT_DEFINE ${BASIC_UTILS_H} || NOT_DEFINE ${LOGGS_H} || NOT_DEFINE ${TRUE_TEST_H} ; then
			. ${LIB_DIR}/include '<host_ip.h>'
			. ${LIB_DIR}/include '<basic_utils.h>'
			. ${LIB_DIR}/include '<loggs.h>'
			. ${LIB_DIR}/include '<true_test.h>'
		fi 
		
		: ${PID_MAX:=$(cat /proc/sys/kernel/pid_max 2>/dev/null || echo -n 32768)}
		
		function httpd_start() {
			${PHP_PARSER} -S ${HOST_IP}:4020 -t ${DOC_ROOT} 1>${LOGS_FILE} 2>&1 &
			local pid_s=$!
			
			logger_logging ${LOGS_FILE}
			[ ${pid_s} -gt 1 ] && [ ${pid_s} -le ${PID_MAX} ] && { echo -n "${pid_s}|${HOST_IP}"; } || { echo -n "-1"; }
		}
		
		#test server is runing
		function server_is_not_running() {
			check_is_file ${FILE_TEST_SERV_RUNNING} && return ${FAILURE} || return ${SUCCESS}
		}
		
	}
fi
