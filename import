#!/bin/bash

#===========================================================================================
# Copyright (C) 2017 Nafiu Shaibu.
# Purpose: General library including system
#-------------------------------------------------------------------------------------------
# This is is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option) 
# any later version.

# This is distributed in the hopes that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#===========================================================================================

: ${LIB_DIR:=$HOME/my_script/QB}

. ${LIB_DIR}/include


if [[ $1 = "<init.h>" ]]; then
	
	if NOT_DEFINE ${INIT_H}; then
		DEFINE INIT_H

		##global variables
		: ${HD_IMG_DIR:="$HOME/.img_qemubox"}
		: ${TEMP_FOLDER:="${HD_IMG_DIR}/.tmp_qbox"}
		: ${QDB_FOLDER=:"${HD_IMG_DIR}/.qdb"} ##qbox database files location
		: ${LOG_DIR:="${HD_IMG_DIR}/logs_dir"}
		: ${BOOT_DIR:="${HD_IMG_DIR}/.qemuboot"} ## contain boot files
		
		
		#librarry dir 
		: ${LIB_DIR:=$HOME/my_script/QB}
		
		#python directory
		: ${PYTHON_LOC:=${QBOX_DIR}/python3}
		
		#Installation Directory 
		: ${QBOX_DIR:="/usr/local/bin/QBox"}
		
		export SDL_VIDEO_X11_DGAMOUSE=0 ##to prevent qemu cursor from been difficult to control
		
		[ ! -d ${HD_IMG_DIR} ] && mkdir ${HD_IMG_DIR} ##Check and creates Harddisk image folder
		[ ! -d ${BOOT_DIR} ] && mkdir ${BOOT_DIR} ##check and create boot folder
		[ ! -d ${QDB_FOLDER} ] && mkdir ${QDB_FOLDER} ##check for qbox database folder
		[ ! -d ${TEMP_FOLDER} ] && mkdir ${TEMP_FOLDER} ##check and creates tmp folder
		[ ! -d ${LOG_DIR} ] && mkdir ${LOG_DIR} && touch ${LOG_DIR}/qboxlog ##check and create log directory
		[ ! -f ${QDB_FOLDER}/pid.qdb ] && touch ${QDB_FOLDER}/pid.qdb ##check pid database vm_name|pid
		[ ! -f ${QDB_FOLDER}/vms.qdb ] && touch ${QDB_FOLDER}/vms.qdb
		
		echo -ne "\033]0;QBox Easy VM Manager \007"
	fi 
	
elif [[ $1 = "<notify.h>" ]]; then
	
	NOT_DEFINE ${NOTIFY_H} && {
		DEFINE NOTIFY_H
		
		: ${NOTICE:=`${QBOX_DIR}/bash_s/check_pkg_install.sh %CHECK_RUN% notify-send`}
	}
	
elif [[ $1 = "<qdb_database.h>" ]]; then
	
	NOT_DEFINE ${QDB_DATABASE_H} && {
		DEFINE QDB_DATABASE_H
		
		. ${LIB_DIR}/import '<init.h>'
		
		DEFINE ARR_IS_EMPTY -1
		DEFINE SRCH_VAL_NOT_IN_ARR -2
		
		if NOT_DEFINE ${ERROR_H} || NOT_DEFINE ${BASIC_UTILS_H}; then
			. ${LIB_DIR}/include '<error.h>'
			. ${LIB_DIR}/include '<basic_utils.h>'
		fi 
		
		: ${VMS_DB:="${QDB_FOLDER}/vms.qdb"}
		: ${PID_DB:="${QDB_FOLDER}/pid.qdb"}
		
		function return_first_field() {
			if check_is_file $1 ; then
				echo "$(cut -d"|" -f1 $1)"
			else 
				echo "$(echo $1 | cut -d"|" -f1)"
			fi 
		}
		
		function return_second_field() {
			if check_is_file $1; then
				echo "$(cut -d"|" -f2 $1)"
			else 
				echo "$(echo $1 | cut -d"|" -f2)"
			fi 
		}
		
		# value, input file, output file
		function complement_of() {
			local search="^$1\$"
			gawk -F "|" -v var=$search '$1 !~ var {print $0 "\n"}' $1 1>$3
		}
		
		#it returns the name of all vms by assigned it to an array and return SUCCESS if successful
		#ARGU: DB_NAME
		#RET: ARR_
		function init_database_qdb() {
			local i=0
			local -a qdb_name
			check_is_file $1 && {
				if [[ "<$1" != "" ]]; then
					for j in $(cat $1); do 
						qdb_name[$i]="\"$j\""
						(( i++ ))
					done 
					echo "${qdb_name[@]}"
				fi 
			} || { err_code=${QDB_NOT_EXIT}; }
			
			
		}
		
		#ARGU:	VALUE_TO_SEARCH_FOR, SIZE_OF_ARR
		#RET:	ARR_INDEX
		function search_val_qdb() {
			[ $2 -eq 0 ] && return ${ARR_IS_EMPTY}
			
			for (( index=0; index<$2; index++ )); do 
				[ "${QDB_NAME[$index]%%:*}" = "$(String_to_Upper $1)" ] && return ${index} 
			done 
			
			return ${SRCH_VAL_NOT_IN_ARR}
		}
		
		###generate string from arr of vms sizeof_arr, set_str
		function names_str_qdb() {
			local -a qdb_name=( $@ )
			local gen_str=""
			local str_tmp=""
			
			for (( index=0; index<${#qdb_name[@]}; index++ )); do 
					str_tmp="${qdb_name[$index]//\"/}"
					str_tmp="${str_tmp// /_}"
					gen_str+="%$(( index+1 ))%${str_tmp%%|*}"
			done
			
			echo -n ${gen_str//%/ }
		}
		
		#argu: db_name, var_to_insert
		function insert_into_qdb() {
			echo $2>>$1
		}
		
		#argu:	search_index, size_of_arr, name_of_vm_to_del, db_name
		function delete_val_qdb() {
			[ $1 -eq ${ARR_IS_EMPTY} ] && return
			[ $1 -eq ${SRCH_VAL_NOT_IN_ARR} ] && return 
			
			local key=$1
			local boot_file_name=$(return_second_field ${QDB_NAME[$key]})
			
			while [[ "${key}" -lt "$2" ]]; do 
				QDB_NAME[$key]=${QDB_NAME[$(( key + 1 ))]}
				
				(( key++ ))
			done
			
			unset ${QDB_NAME[$2]}
			
			##-----commit changes to db files--------------
			local TMPFILE=$(mktemp -uq qbox.XXXXXXXXXXXX || echo "qbox.$$")
			complement_of $3 $4 "${QDB_FOLDER}/${TMPFILE}"
			
			mv "${QDB_FOLDER}/${TMPFILE}" $4 
			rm -f ${boot_file_name} 2>/dev/null
			rm -f ${HD_IMG_DIR}/$(sed 's/img/qvm/' `basename ${boot_file_name}`) 2>/dev/null
			
			return $(expr $2 -1 )
		}
		
	}
	
elif [[ $1 = "<boot_vm.h>" ]]; then
	
	NOT_DEFINE ${BOOT_VM_H} && {
		DEFINE BOOT_VM_H
		
		. ${LIB_DIR}/import '<qdb_database.h>'
		
		if NOT_DEFINE ${TRUE_TEST_H}; then
			. ${LIB_DIR}/include '<true_test.h>'
		fi 
		
		##arrgu: bootfile, name of vm
		function boot_vm() {
			local boot_config=""
			local boot_file_loc="${BOOT_DIR}/$1"
			
			if check_is_file ${boot_file_loc}; then
				boot_config=$(cat ${boot_file_loc} | cut -d"|" -f2 | sed ':a;N;$!ba;s/\n/ /g')
				
				boot_config=`echo ${boot_config} | tr -s " "` ##Replace multiple space char with a space char
				
				boot_config=${boot_config// ,/,} ##Replace " ," with ","
				
				${boot_config} 2>/dev/null &
				local pid_vm=$!
				
				insert_into_qdb ${PID_DB} "$2|${pid_vm}"
				return ${SUCCESS}
			else 
				return ${FAILURE}
			fi 
		}
	}
fi
